# íŠ¸ìœ„í„° APIì™€ LLMì„ í™œìš©í•œ ì½”ì¸ ê°ì • ë¶„ì„ ë° íŠ¸ë ˆì´ë”© ì‹œê·¸ë„ ì‹œìŠ¤í…œ
# pip install requests python-dotenv apscheduler
# 1. í•„ìš”í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ê°€ì ¸ì˜¤ê¸°
import os
import json
import time
import random
import requests
from datetime import datetime, timedelta
import logging
from dotenv import load_dotenv

# í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
load_dotenv()

# ë¡œê¹… ì„¤ì •
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# 2. ëª¨ë‹ˆí„°ë§í•  ì¸í”Œë£¨ì–¸ì„œ ëª©ë¡ ì„¤ì •
influencers = [
    {"name": "Elon Musk", "twitter_username": "elonmusk", "coins": ["DOGE", "SHIB", "FLOKI"]},
    {"name": "Donald Trump", "twitter_username": "realDonaldTrump", "coins": ["TRUMP", "MAGA"]},
    {"name": "Michael Saylor", "twitter_username": "saylor", "coins": ["BTC"]},
    {"name": "Vitalik Buterin", "twitter_username": "VitalikButerin", "coins": ["ETH"]}
]

# 3. ì½”ì¸ë³„ ê³¼ê±° ë°˜ì‘ íŒ¨í„´ ë°ì´í„° (ì‹¤ì œë¡œëŠ” DBì—ì„œ ê´€ë¦¬)
coin_patterns = {
    'DOGE': {
        'avgReactionTimeMinutes': 7,
        'avgPriceImpactPercent': 12,
        'positiveKeywords': ['dog', 'moon', 'favorite', 'love'],
        'negativeKeywords': ['sell', 'overvalued']
    },
    'TRUMP': {
        'avgReactionTimeMinutes': 15,
        'avgPriceImpactPercent': 35,
        'positiveKeywords': ['president', 'win', 'election', 'victory'],
        'negativeKeywords': ['case', 'trial', 'verdict']
    },
    'BTC': {
        'avgReactionTimeMinutes': 10,
        'avgPriceImpactPercent': 5,
        'positiveKeywords': ['reserve', 'property', 'hope', 'acquire', 'hold'],
        'negativeKeywords': ['sell', 'risk', 'ban', 'regulation']
    },
    'ETH': {
        'avgReactionTimeMinutes': 12,
        'avgPriceImpactPercent': 8,
        'positiveKeywords': ['scaling', 'staking', 'defi', 'layer 2', 'upgrade'],
        'negativeKeywords': ['delay', 'issue', 'problem', 'bug']
    },
    'SHIB': {
        'avgReactionTimeMinutes': 8,
        'avgPriceImpactPercent': 15,
        'positiveKeywords': ['dog', 'community', 'cute', 'pet'],
        'negativeKeywords': ['dump', 'meme', 'joke']
    },
    'FLOKI': {
        'avgReactionTimeMinutes': 5,
        'avgPriceImpactPercent': 25,
        'positiveKeywords': ['puppy', 'cute', 'moon', 'pet'],
        'negativeKeywords': ['sell', 'scam', 'joke']
    },
    'MAGA': {
        'avgReactionTimeMinutes': 14,
        'avgPriceImpactPercent': 30,
        'positiveKeywords': ['america', 'win', 'great', 'huge'],
        'negativeKeywords': ['lose', 'bad', 'fake']
    }
}

# 4. ë”ë¯¸ íŠ¸ìœ— ìƒì„± í•¨ìˆ˜
def get_recent_tweets(username, count=10):
    """ë”ë¯¸ íŠ¸ìœ— ë°ì´í„° ìƒì„±"""
    logger.info(f"{username}ì˜ ë”ë¯¸ íŠ¸ìœ— ìƒì„± ì¤‘...")
    
    dummy_tweets = []
    
    # ì¸í”Œë£¨ì–¸ì„œë³„ ë”ë¯¸ íŠ¸ìœ— ìƒì„±
    if "elonmusk" in username.lower():
        tweet_options = [
            "Dogecoin might be my favorite cryptocurrency. It's pretty cool.",
            "Thinking about the future of sustainable energy and cryptocurrency mining.",
            "Just bought some more Bitcoin because why not",
            "My Shiba Inu puppy is so cute today!",
            "Floki to the moon!",
            "DOGE will be used as currency on Mars",
            "Considering accepting DOGE for Tesla purchases",
            "Crypto is the future of finance",
            "Working on FLOKI utility, stay tuned",
            "SHIB has an interesting community"
        ]
        author_id = "44196397"
    elif "trump" in username.lower():
        tweet_options = [
            "MAKE AMERICA GREAT AGAIN! #MAGA",
            "We're going to win, and we're going to win big in the markets too!",
            "Our economy is the strongest it's ever been. Tremendous!",
            "The election is coming up. Victory for America!",
            "America First policies are working!",
            "TRUMP currency is going to be huge, believe me!",
            "MAGA coin supporters are the best supporters",
            "We're building something big with cryptocurrency",
            "Nobody understands markets better than me",
            "Very exciting news about MAGA coin coming soon"
        ]
        author_id = "25073877"
    elif "saylor" in username.lower():
        tweet_options = [
            "Bitcoin is digital property and the first engineered monetary system in the history of the world.",
            "Just acquired another 1000 BTC for the corporate treasury.",
            "Bitcoin is hope for billions of people across the planet.",
            "The most efficient use of energy in the world is the Bitcoin network.",
            "We now hold more than 100,000 BTC as our primary treasury reserve asset.",
            "Bitcoin is the apex property of the human race",
            "BTC scarcity is accelerating with the halving",
            "Our strategy remains: acquire and hold Bitcoin",
            "Traditional currencies are melting in your pocket while BTC appreciates",
            "Added 500 more BTC to treasury this morning"
        ]
        author_id = "244647486"
    elif "vitalik" in username.lower():
        tweet_options = [
            "Ethereum 2.0 progress is looking good. Exciting developments ahead.",
            "Working on improving scalability solutions for ETH.",
            "The future of decentralized finance is bright.",
            "Exploring new technical possibilities for Ethereum L2 solutions.",
            "Just donated 100 ETH to support open source development.",
            "ETH staking yields are stabilizing nicely",
            "Zero-knowledge proofs will transform scalability",
            "Layer 2 is where most transaction volume will live",
            "Protocol improvements coming in next update",
            "Community governance of ETH is maturing well"
        ]
        author_id = "295218901"
    else:
        tweet_options = [f"ì´ê²ƒì€ {username}ì˜ ë”ë¯¸ íŠ¸ìœ— #{i+1}ì…ë‹ˆë‹¤. ì´ íŠ¸ìœ—ì€ ë°ëª¨ìš©ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤." for i in range(20)]
        author_id = "000000"
    
    # ëœë¤í•˜ê²Œ íŠ¸ìœ— ì„ íƒ
    selected_tweets = random.sample(tweet_options, min(count, len(tweet_options)))
    
    # ìµœê·¼ ë‚ ì§œ/ì‹œê°„ ìƒì„± (ìµœê·¼ 3ì¼ ì´ë‚´)
    def random_recent_time():
        now = datetime.now()
        random_hours = random.randint(1, 72)  # ìµœê·¼ 3ì¼ ì´ë‚´
        return now - timedelta(hours=random_hours)
    
    # íŠ¸ìœ— ê°ì²´ ìƒì„±
    for i, tweet_text in enumerate(selected_tweets):
        created_at = random_recent_time()
        
        tweet_obj = {
            "id": f"{int(time.time())}{i}",
            "text": tweet_text,
            "created_at": created_at,
            "author_id": author_id,
            "public_metrics": {
                "like_count": random.randint(1000, 50000),
                "retweet_count": random.randint(100, 5000),
                "reply_count": random.randint(50, 2000),
                "quote_count": random.randint(10, 500)
            }
        }
        dummy_tweets.append(tweet_obj)
    
    return dummy_tweets

# 5. ì½”ì¸ ê°€ê²© ë°ì´í„° ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜ (ë”ë¯¸)
def get_coin_price(symbol):
    """ë”ë¯¸ ì½”ì¸ ê°€ê²© ë°ì´í„° ìƒì„±"""
    try:
        # ì‹¤ì œ API í˜¸ì¶œ ì‹œë„ (ì„ íƒì )
        try:
            response = requests.get(f"https://api.binance.com/api/v3/ticker/price?symbol={symbol}USDT", timeout=2)
            data = response.json()
            return float(data['price'])
        except Exception:
            pass  # API í˜¸ì¶œ ì‹¤íŒ¨ ì‹œ ë”ë¯¸ ë°ì´í„° ì‚¬ìš©
        
        # ë”ë¯¸ ê°€ê²© ë°ì´í„°
        dummy_prices = {
            'DOGE': 0.08 + (random.random() * 0.02),
            'SHIB': 0.00002 + (random.random() * 0.000005),
            'FLOKI': 0.0001 + (random.random() * 0.00002),
            'BTC': 65000 + (random.random() * 5000),
            'ETH': 3500 + (random.random() * 300),
            'TRUMP': 0.5 + (random.random() * 0.2),
            'MAGA': 1.2 + (random.random() * 0.5)
        }
        return dummy_prices.get(symbol, 1.0)
    except Exception as e:
        logger.error(f"ê°€ê²© ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜: {e}")
        return 1.0  # ì˜¤ë¥˜ ì‹œ ê¸°ë³¸ê°’

# 6. íŠ¸ìœ— ê°ì • ë¶„ì„ í•¨ìˆ˜ (ë”ë¯¸)
def analyze_tweet(tweet, coin_symbol):
    """ë”ë¯¸ ê°ì • ë¶„ì„ ê²°ê³¼ ìƒì„±"""
    # ì½”ì¸ê³¼ íŠ¸ìœ— ë‚´ìš© ê¸°ë°˜ìœ¼ë¡œ ë”ë¯¸ ë¶„ì„ ê²°ê³¼ ìƒì„±
    is_positive = any(keyword in tweet['text'].lower() for keyword in ['moon', 'up', 'rise', 'buy', 'bull', 'great', 'good', 'positive', 'win', 'victory', 'launch'])
    is_negative = any(keyword in tweet['text'].lower() for keyword in ['down', 'fall', 'sell', 'bear', 'bad', 'negative', 'case', 'trial', 'problem', 'issue'])
    
    # ì½”ì¸ë³„ í‚¤ì›Œë“œ ì²´í¬
    pattern = coin_patterns.get(coin_symbol, {})
    positive_keywords = pattern.get('positiveKeywords', [])
    negative_keywords = pattern.get('negativeKeywords', [])
    
    # ì½”ì¸ ê´€ë ¨ í‚¤ì›Œë“œ ì²´í¬
    is_positive = is_positive or any(keyword in tweet['text'].lower() for keyword in positive_keywords)
    is_negative = is_negative or any(keyword in tweet['text'].lower() for keyword in negative_keywords)
    
    # ê¸°ë³¸ê°’ì€ ì¤‘ë¦½
    sentiment = "neutral"
    confidence = random.randint(50, 70)
    impact = "ì¤‘ë¦½"
    price_change = random.uniform(-1, 1)
    action = "hold"
    leverage = random.randint(1, 3)
    risk = "medium"
    
    # ê¸ì •ì  ë‚´ìš©ì´ ìˆìœ¼ë©´
    if is_positive:
        sentiment = "positive"
        confidence = random.randint(70, 95)
        impact = random.choice(["ê¸ì •ì ", "ë§¤ìš° ê¸ì •ì "])
        price_change = random.uniform(2, 15)
        action = "buy"
        leverage = random.randint(3, 10)
        risk = random.choice(["medium", "high"])
    
    # ë¶€ì •ì  ë‚´ìš©ì´ ìˆìœ¼ë©´
    elif is_negative:
        sentiment = "negative"
        confidence = random.randint(70, 90)
        impact = random.choice(["ë¶€ì •ì ", "ë§¤ìš° ë¶€ì •ì "])
        price_change = random.uniform(-15, -2)
        action = "sell"
        leverage = random.randint(3, 8)
        risk = random.choice(["medium", "high"])
    
    # ì„¤ëª… ìƒì„±
    explanation = f"ë¶„ì„: ì´ íŠ¸ìœ—ì€ {coin_symbol}ì— ëŒ€í•´ {'ê¸ì •ì ' if is_positive else 'ë¶€ì •ì ' if is_negative else 'ì¤‘ë¦½ì '} ë‚´ìš©ì„ ë‹´ê³  ìˆìŠµë‹ˆë‹¤. "
    explanation += f"íŠ¹íˆ {'ê¸ì •ì  í‚¤ì›Œë“œ' if is_positive else 'ë¶€ì •ì  í‚¤ì›Œë“œ' if is_negative else 'ë‘ë“œëŸ¬ì§„ ê°ì •ì  í‘œí˜„ì´ ì—†ìŒ'}ì´ ê´€ì°°ë©ë‹ˆë‹¤. "
    explanation += f"ê³¼ê±° ìœ ì‚¬í•œ íŠ¸ìœ—ì€ {abs(price_change):.2f}% ì •ë„ì˜ {'ìƒìŠ¹' if price_change > 0 else 'í•˜ë½'} ì˜í–¥ì„ ì£¼ì—ˆìŠµë‹ˆë‹¤."
    
    return {
        "sentiment": sentiment,
        "confidenceScore": confidence,
        "predictedImpact": impact,
        "estimatedPriceChangePercent": price_change,
        "reasoningExplanation": explanation,
        "recommendedAction": action,
        "recommendedLeverageMultiple": leverage,
        "riskLevel": risk
    }

# 7. ì½”ì¸ ê´€ë ¨ í‚¤ì›Œë“œ í™•ì¸ í•¨ìˆ˜
def check_related_keywords(text, coin_symbol):
    """íŠ¸ìœ—ì´ ì½”ì¸ê³¼ ê´€ë ¨ìˆëŠ”ì§€ í™•ì¸"""
    pattern = coin_patterns.get(coin_symbol)
    if not pattern:
        return False
    
    lower_text = text.lower()
    
    # ì½”ì¸ ì´ë¦„ í¬í•¨ ì—¬ë¶€
    if coin_symbol.lower() in lower_text:
        return True
    
    # ê¸ì •/ë¶€ì • í‚¤ì›Œë“œ ì²´í¬
    for keyword in pattern['positiveKeywords']:
        if keyword.lower() in lower_text:
            return True
    
    for keyword in pattern['negativeKeywords']:
        if keyword.lower() in lower_text:
            return True
    
    return False

# 8. ìµœì  ì§„ì…/ì²­ì‚° ì‹œê°„ ê³„ì‚° í•¨ìˆ˜
def calculate_optimal_entry_window(coin_symbol):
    """ìµœì  ì§„ì… ì‹œê°„ ê³„ì‚°"""
    pattern = coin_patterns.get(coin_symbol)
    if not pattern:
        return {"start": "ì¦‰ì‹œ", "end": "5ë¶„ ì´ë‚´"}
    
    return {
        "start": "ì¦‰ì‹œ",
        "end": f"{round(pattern['avgReactionTimeMinutes'] * 0.7)}ë¶„ ì´ë‚´"
    }

def calculate_optimal_exit_window(coin_symbol, estimated_change):
    """ìµœì  ì²­ì‚° ì‹œê°„ ê³„ì‚°"""
    pattern = coin_patterns.get(coin_symbol)
    if not pattern:
        return {"start": "15ë¶„ í›„", "end": "1ì‹œê°„ ì´ë‚´"}
    
    multiplier = abs(estimated_change) / pattern['avgPriceImpactPercent']
    exit_start = round(pattern['avgReactionTimeMinutes'] * (1.2 if multiplier > 1 else 0.8))
    exit_end = round(pattern['avgReactionTimeMinutes'] * (3 if multiplier > 1 else 2))
    
    return {
        "start": f"{exit_start}ë¶„ í›„",
        "end": f"{exit_end}ë¶„ ì´ë‚´"
    }

# 9. ê±°ë˜ ì‹œê·¸ë„ ìƒì„± í•¨ìˆ˜
def generate_trading_signal(analysis, coin_symbol, tweet):
    """ê±°ë˜ ì‹œê·¸ë„ ìƒì„±"""
    # ìµœì  ì§„ì…/ì²­ì‚° ì‹œê°„ ê³„ì‚°
    optimal_entry_window = calculate_optimal_entry_window(coin_symbol)
    optimal_exit_window = calculate_optimal_exit_window(coin_symbol, analysis["estimatedPriceChangePercent"])
    
    signal = {
        "timestamp": datetime.now().isoformat(),
        "coinSymbol": coin_symbol,
        "tweetId": tweet['id'],
        "tweetText": tweet['text'],
        "tweetAuthor": tweet['author_id'],
        "sentiment": analysis["sentiment"],
        "confidenceScore": analysis["confidenceScore"],
        "predictedImpact": analysis["predictedImpact"],
        "estimatedPriceChangePercent": analysis["estimatedPriceChangePercent"],
        "recommendedAction": analysis["recommendedAction"],
        "recommendedLeverageMultiple": analysis["recommendedLeverageMultiple"],
        "riskLevel": analysis["riskLevel"],
        "reasoning": analysis["reasoningExplanation"],
        "optimalEntryWindow": optimal_entry_window,
        "optimalExitWindow": optimal_exit_window,
        "currentPrice": get_coin_price(coin_symbol)
    }
    
    return signal

# 10. ì‹œê·¸ë„ ì €ì¥ í•¨ìˆ˜
def save_signal(signal):
    """ê±°ë˜ ì‹œê·¸ë„ ì €ì¥"""
    signal_file = 'trading_signals.json'
    try:
        # íŒŒì¼ì´ ìˆìœ¼ë©´ ì½ê¸°
        if os.path.exists(signal_file):
            with open(signal_file, 'r', encoding='utf-8') as f:
                signals = json.load(f)
        else:
            signals = []
        
        # ìƒˆ ì‹œê·¸ë„ ì¶”ê°€
        signals.append(signal)
        
        # íŒŒì¼ì— ì €ì¥
        with open(signal_file, 'w', encoding='utf-8') as f:
            json.dump(signals, f, ensure_ascii=False, indent=2)
            
    except Exception as e:
        logger.error(f"ì‹œê·¸ë„ ì €ì¥ ì˜¤ë¥˜: {e}")
        # ìƒˆ íŒŒì¼ ìƒì„±
        with open(signal_file, 'w', encoding='utf-8') as f:
            json.dump([signal], f, ensure_ascii=False, indent=2)

# 11. ì•Œë¦¼ ì „ì†¡ í•¨ìˆ˜
def send_alert(signal):
    """íŠ¸ë ˆì´ë”© ì‹œê·¸ë„ ì•Œë¦¼"""
    logger.info(f"ğŸš¨ ì•Œë¦¼: {signal['coinSymbol']} {signal['recommendedAction'].upper()} ì‹œê·¸ë„ ë°œìƒ")
    logger.info(f"ğŸ’° ì¶”ì²œ ë ˆë²„ë¦¬ì§€: {signal['recommendedLeverageMultiple']}ë°°")
    logger.info(f"â±ï¸ ìµœì  ì§„ì… ì‹œê°„: {signal['optimalEntryWindow']['start']} ~ {signal['optimalEntryWindow']['end']}")
    logger.info(f"ğŸ”„ ìµœì  ì²­ì‚° ì‹œê°„: {signal['optimalExitWindow']['start']} ~ {signal['optimalExitWindow']['end']}")
    logger.info(f"ğŸ’µ í˜„ì¬ ê°€ê²©: ${signal['currentPrice']:.6f}")
    logger.info(f"ğŸ“Š ì˜ˆìƒ ê°€ê²© ë³€ë™: {signal['estimatedPriceChangePercent']:.2f}%")
    logger.info(f"ğŸ” ê·¼ê±°: {signal['reasoning']}")

# 12. ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜
def main():
    logger.info("ì½”ì¸ ì¸í”Œë£¨ì–¸ì„œ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì‹œì‘...")
    
    # ëª¨ë“  ì¸í”Œë£¨ì–¸ì„œì— ëŒ€í•´ ìµœê·¼ íŠ¸ìœ— ê°€ì ¸ì˜¤ê¸°
    for influencer in influencers:
        logger.info(f"{influencer['name']}ì˜ ìµœê·¼ íŠ¸ìœ— í™•ì¸ ì¤‘...")
        tweets = get_recent_tweets(influencer['twitter_username'])
        
        if not tweets:
            logger.info(f"{influencer['name']}ì˜ ìµœê·¼ íŠ¸ìœ—ì´ ì—†ìŠµë‹ˆë‹¤.")
            continue
        
        # ê´€ë ¨ ì½”ì¸ì— ëŒ€í•´ ê° íŠ¸ìœ— ë¶„ì„
        for coin in influencer['coins']:
            logger.info(f"{coin} ê´€ë ¨ íŠ¸ìœ— ë¶„ì„ ì¤‘...")
            
            for tweet in tweets:
                # ì½”ì¸ ê´€ë ¨ í‚¤ì›Œë“œê°€ ìˆëŠ”ì§€ í™•ì¸
                is_coin_related = check_related_keywords(tweet['text'], coin)
                
                if not is_coin_related:
                    continue
                
                logger.info(f"ì½”ì¸ ê´€ë ¨ íŠ¸ìœ— ë°œê²¬: {tweet['text'][:50]}...")
                
                # íŠ¸ìœ— ë¶„ì„
                analysis = analyze_tweet(tweet, coin)
                
                if analysis:
                    # ê±°ë˜ ì‹œê·¸ë„ ìƒì„±
                    trading_signal = generate_trading_signal(analysis, coin, tweet)
                    
                    # ì‹œê·¸ë„ ì €ì¥ ë° ì•Œë¦¼
                    save_signal(trading_signal)
                    send_alert(trading_signal)
                    
                    logger.info(f"âœ… {coin} ê±°ë˜ ì‹œê·¸ë„ ìƒì„±ë¨")
    
    logger.info("ëª¨ë‹ˆí„°ë§ ì™„ë£Œ")

# 13. ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì • (ì£¼ê¸°ì  ì‹¤í–‰)
def run_scheduler():
    from apscheduler.schedulers.blocking import BlockingScheduler
    
    scheduler = BlockingScheduler()
    # 5ë¶„ë§ˆë‹¤ ì‹¤í–‰
    scheduler.add_job(main, 'interval', minutes=5)
    
    try:
        logger.info("ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘... (Ctrl+Cë¡œ ì¤‘ì§€)")
        scheduler.start()
    except KeyboardInterrupt:
        logger.info("ìŠ¤ì¼€ì¤„ëŸ¬ ì¢…ë£Œ")

# í”„ë¡œê·¸ë¨ ì‹¤í–‰
if __name__ == "__main__":
    try:
        # í•œ ë²ˆ ì‹¤í–‰í•˜ë ¤ë©´:
        main()
        
        # ì£¼ê¸°ì ìœ¼ë¡œ ì‹¤í–‰í•˜ë ¤ë©´:
        # run_scheduler()
    except Exception as e:
        logger.error(f"ì‹œìŠ¤í…œ ì˜¤ë¥˜: {e}")